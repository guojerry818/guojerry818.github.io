<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JZ-04.二维数组</title>
    <link href="/2023/03/22/JZ04.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/22/JZ04.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:<br>现有矩阵 matrix 如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,   4,  7, 11, 15]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,   5,  8, 12, 19]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,   6,  9, 16, 22]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[10, 13, 14, 17, 24]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[18, 21, 23, 26, 30]</span></span><br><span class="hljs-comment">]</span><br><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。<br>给定 target &#x3D; 20，返回 false。</p><p>限制：<br><code>0 &lt;= n &lt;= 1000</code><br><code>0 &lt;= m &lt;= 1000</code></p><h2 id="题解1：BST思想，简单好抄"><a href="#题解1：BST思想，简单好抄" class="headerlink" title="题解1：BST思想，简单好抄"></a>题解1：BST思想，简单好抄</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//BST：右上角开始搜索</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>())    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//数组空返回否</span><br>        <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>();      <span class="hljs-comment">//最大行</span><br>        <span class="hljs-type">int</span> m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();   <span class="hljs-comment">//列</span><br>        <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=m<span class="hljs-number">-1</span>;             <span class="hljs-comment">//x当前行；y当前列</span><br>        <span class="hljs-keyword">while</span>(x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[x][y]==target)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(matrix[x][y]&gt;target)     y--;<br>            <span class="hljs-keyword">else</span>    x++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思想：<br>由于二维矩阵从上到下，从左到右都<strong>非递减</strong>，因此从右上角看，就是BST。因此从右上角开始搜索即可达到 $C(m+n)$ 的时间复杂度。</p><h2 id="题解2：二分搜索，平民单核"><a href="#题解2：二分搜索，平民单核" class="headerlink" title="题解2：二分搜索，平民单核"></a>题解2：二分搜索，平民单核</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row: matrix) &#123;<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(row.<span class="hljs-built_in">begin</span>(), row.<span class="hljs-built_in">end</span>(), target);<br>            <span class="hljs-keyword">if</span> (it != row.<span class="hljs-built_in">end</span>() &amp;&amp; *it == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思想：<br>这也是我最开始想到的方法。但是做了半天修修改改也没有Ac，没想到题解这么短。<br>自己开始想的是先二分搜索各行第一个元素，然后二分搜索各列（显然想复杂了）。<br>题解对每一行都用了一次二分，实现了 $O(nlogm)$ 的时间复杂度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Leetcode刷题日记</tag>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-17. 电话号码的字母组合</title>
    <link href="/2023/03/17/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2023/03/17/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。</p><p>示例 1：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p>提示：<br>    0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>    digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">if</span>(digits==<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span> ans;<br>        n=digits.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">getCombinations</span>(ans,digits,<span class="hljs-string">&quot;&quot;</span>,digits.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCombinations</span><span class="hljs-params">(vector&lt;string&gt; &amp;ans,string digits,string str,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(t&lt;=<span class="hljs-number">0</span>)    &#123;ans.<span class="hljs-built_in">push_back</span>(str);   <span class="hljs-keyword">return</span> ;&#125;<br>        <span class="hljs-keyword">switch</span>(digits[digits.<span class="hljs-built_in">size</span>()-t])<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">97</span>;i&lt;<span class="hljs-number">100</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">100</span>;i&lt;<span class="hljs-number">103</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">103</span>;i&lt;<span class="hljs-number">106</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">106</span>;i&lt;<span class="hljs-number">109</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">109</span>;i&lt;<span class="hljs-number">112</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">112</span>;i&lt;<span class="hljs-number">116</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">116</span>;i&lt;<span class="hljs-number">119</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">119</span>;i&lt;<span class="hljs-number">123</span>;i++)   <span class="hljs-built_in">getCombinations</span>(ans,digits,str+(<span class="hljs-type">char</span>)i,t<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：<br>因为之前做了 22.括号生成 那道题，题解有使用递归dfs方法，感觉很精妙。所以这次回顾了一下那道题，自己写出来的。修修补补，还使用了switch判断，有点冗杂了，可以用map替代的。不过好在能够正常运行。之后二刷的时候再试试别的方法吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Leetcode刷题日记</tag>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-19. 删除链表的倒数第N个结点</title>
    <link href="/2023/03/16/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2023/03/16/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>提示：<br>    链表中结点的数目为 sz<br>    1 &lt;&#x3D; sz &lt;&#x3D; 30<br>    0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>    1 &lt;&#x3D; n &lt;&#x3D; sz</p><h2 id="题解1：简单二次遍历"><a href="#题解1：简单二次遍历" class="headerlink" title="题解1：简单二次遍历"></a>题解1：简单二次遍历</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head)   <span class="hljs-keyword">return</span> head;<br>        ListNode *fast=head;        <span class="hljs-comment">//非快慢指针法</span><br>        ListNode *slow=head;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast)<br>        &#123;<br>            fast=fast-&gt;next;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)<br>        &#123;<br>            head=<span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==n)<br>        &#123;<br>            head=slow-&gt;next;<br>            slow=<span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k-n<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            slow=slow-&gt;next;<br>        &#125;<br>        fast=slow-&gt;next;<br>        slow-&gt;next=fast-&gt;next;<br>        fast=<span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p> 思想：<br> 简单的两次遍历链表。第一次遍历记录链表总长度，第二次删除对应结点。属于一下就能想到的方法。<br> 尽管如此，仍然有两个需要注意的情况：</p><ol><li>当前链表只有一个结点时的情况</li><li>要删除的结点是头结点的情况</li></ol><h2 id="题解2：简短递归"><a href="#题解2：简短递归" class="headerlink" title="题解2：简短递归"></a>题解2：简短递归</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head)   <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;                  <span class="hljs-comment">//当链表为空，直接返回空</span><br>        <br>        head-&gt;next=<span class="hljs-built_in">removeNthFromEnd</span>(head-&gt;next,n);   <span class="hljs-comment">//这一步的本质：递归+删结点</span><br>        k++;                                         <span class="hljs-comment">//记录当前结点位数</span><br>        <span class="hljs-keyword">if</span>(n==k)    <span class="hljs-keyword">return</span> head-&gt;next;            <span class="hljs-comment">//当遍历到需要删除的结点时，返回next结点</span><br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思想：<br>其实我第二想法是快慢指针法（从我代码变量命名应该能看出来），但是相比较而言并不高明，所需要考虑的特殊情况依然需要特殊处理。<br>当我看到讨论区里的这个递归，简直惊了：<strong>简短，清晰</strong>（尽管并没有那么好理解）。</p><p>首先，定义变量k用来记录当前遍历到的节点的位置。<br>然后，判断头节点是否为空，如果为空，就返回空（唯一需要考虑的特殊情况）。<br>否则，递归地调用函数，把头节点的next指针作为参数传入，并把返回值赋给头节点的next指针。这样就可以保证每个节点都会被访问到，并且在返回时更新它们的next指针。<br>接着，k加一，表示当前遍历到了第cur个节点。然后，我们判断cur是否等于n，也就是要删除的倒数第n个节点的位置。如果是，那么我们就返回头节点的next指针，也就是跳过了倒数第n个节点。如果不是，那么我们就返回头节点本身。</p><p>用示例1举例：</p><ul><li>当head为1时，我们递归调用函数，并把1-&gt;next作为参数传入。</li><li>当head为2时，我们递归调用函数，并把2-&gt;next作为参数传入。</li><li>当head为3时，我们递归调用函数，并把3-&gt;next作为参数传入。</li><li>当head为4时，我们递归调用函数，并把4-&gt;next作为参数传入。</li><li>当head为5时，由于5-&gt;next为空，所以返回空。此时k为0，并且开始回溯。</li><li>当head为4时（回溯），由于返回值为空（5-&gt;next），所以4-&gt;next也被赋值为空。此时k加一变成1，并且不等于n（2），所以返回4本身。</li><li>当head为3时（回溯），由于返回值为4（4本身），所以3-&gt;next也被赋值为4。此时k加一变成2，并且等于n（2），所以返回3-&gt;next（也就是4）。</li><li>当head为2时（回溯），由于返回值为4（3-&gt;next），所以2-&gt;next也被赋值为4。此时k加一变成3，并且不等于n（2），所以返回2本身。</li><li>当head为1时（回溯），由于返回值为2（2本身），所以1-&gt;next也被赋值为2。此时k加一变成4，并且不等于n（2），所以返回1本身。<br>最后得到链表：1 -&gt; 2 -&gt; 4 -&gt; 5</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Leetcode刷题日记</tag>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-3.无重复字符的最长子串</title>
    <link href="/2023/03/09/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/03/09/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:<br>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：<br>    0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>    s 由英文字母、数字、符号和空格组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;    <br>    <span class="hljs-comment">//注意！并不需要记录最长字串是谁，只需要记录最长字串长度！</span><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;               <span class="hljs-comment">//当字符串长度为0，直接返回0</span><br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; lookup;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;                             <span class="hljs-comment">//窗口左指针</span><br>        <span class="hljs-type">int</span> maxStr=<span class="hljs-number">0</span>;                           <span class="hljs-comment">//记录最大窗口大小</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span> ; right&lt;s.<span class="hljs-built_in">size</span>() ; right++)<br>        <span class="hljs-comment">//循环，向右移动窗口，直到右指针超过字符串大小</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(lookup.<span class="hljs-built_in">find</span>(s[right])!=lookup.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-comment">//当即将插入的元素已经存在于lookup中，窗口逐步滑动【1.去除左指针元素；2.左指针右移】</span><br>            &#123;<br>                lookup.<span class="hljs-built_in">erase</span>(s[left]);<br>                left++;<br>            &#125;<br>            lookup.<span class="hljs-built_in">emplace</span>(s[right]);           <span class="hljs-comment">//将右指针元素放入lookup中，当前窗口构建完成</span><br>            maxStr=<span class="hljs-built_in">max</span>(maxStr,right-left+<span class="hljs-number">1</span>);    <span class="hljs-comment">//计算截止当前最长字串长度</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> maxStr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思想：<br><strong>滑动窗口</strong><br>使用unordered_set存放当前窗口内容（便于查询重复元素）；<br>左右指针（left&#x2F;right）指向字符串，构成滑动窗口；<br>maxStr记录截至目前最长字串长度。</p><p>使用for循环，不断向右移动右指针，直到右指针超出字符串大小；<br>循环内部嵌套while循环查询右指针指向元素是否包含于当前窗口中，若已存在则右移左指针缩小窗口，若不存在则跳出循环（find方法返回end）；<br>插入右指针元素，计算当前最长字串长度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Leetcode刷题日记</tag>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11特性：lambda表达式（匿名函数）</title>
    <link href="/2022/09/20/C++11%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/09/20/C++11%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11特性：lambda表达式（匿名函数）"><a href="#C-11特性：lambda表达式（匿名函数）" class="headerlink" title="C++11特性：lambda表达式（匿名函数）"></a>C++11特性：lambda表达式（匿名函数）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>匿名函数，即没有函数名的函数，用于快速创建函数对象，提高代码简洁程度。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>声明式风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li><li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li><li>在需要的时间和地点实现功能闭包，使程序更灵活。</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[ 捕获列表 ] ( 形参 ) 函数选项 -&gt; 返回值类型 &#123; 函数体 &#125;;<br></code></pre></td></tr></table></figure><p>lambda表达式一般都是以方括号[]开头，有参数就使用()，无参就直接省略()即可，最后结束于{}。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;;  <span class="hljs-comment">//匿名函数主体，其中auto为类型推导</span><br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><ul><li>[] 不捕获任何变量。</li><li>[ &amp; ] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[ &#x3D; ] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> x1 = []&#123; <span class="hljs-keyword">return</span> i_; &#125;;                    <span class="hljs-comment">// error，没有捕获外部变量</span><br>        <span class="hljs-keyword">auto</span> x2 = [=]&#123; <span class="hljs-keyword">return</span> i_ + x + y; &#125;;           <span class="hljs-comment">// OK，捕获所有外部变量</span><br>        <span class="hljs-keyword">auto</span> x3 = [&amp;]&#123; <span class="hljs-keyword">return</span> i_ + x + y; &#125;;           <span class="hljs-comment">// OK，捕获所有外部变量</span><br>        <span class="hljs-keyword">auto</span> x4 = [<span class="hljs-keyword">this</span>]&#123; <span class="hljs-keyword">return</span> i_; &#125;;                <span class="hljs-comment">// OK，捕获this指针</span><br>        <span class="hljs-keyword">auto</span> x5 = [<span class="hljs-keyword">this</span>]&#123; <span class="hljs-keyword">return</span> i_ + x + y; &#125;;        <span class="hljs-comment">// error，没有捕获x、y</span><br>        <span class="hljs-keyword">auto</span> x6 = [<span class="hljs-keyword">this</span>, x, y]&#123; <span class="hljs-keyword">return</span> i_ + x + y; &#125;;  <span class="hljs-comment">// OK，捕获this指针、x、y</span><br>        <span class="hljs-keyword">auto</span> x7 = [<span class="hljs-keyword">this</span>]&#123; <span class="hljs-keyword">return</span> i_++; &#125;;              <span class="hljs-comment">// OK，捕获this指针，并修改成员的值</span><br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> f1 = []&#123; <span class="hljs-keyword">return</span> a; &#125;;               <span class="hljs-comment">// error，没有捕获外部变量</span><br><span class="hljs-keyword">auto</span> f2 = [&amp;]&#123; <span class="hljs-keyword">return</span> a++; &#125;;            <span class="hljs-comment">// OK，捕获所有外部变量，并对a执行自加运算</span><br><span class="hljs-keyword">auto</span> f3 = [=]&#123; <span class="hljs-keyword">return</span> a; &#125;;              <span class="hljs-comment">// OK，捕获所有外部变量，并返回a</span><br><span class="hljs-keyword">auto</span> f4 = [=]&#123; <span class="hljs-keyword">return</span> a++; &#125;;            <span class="hljs-comment">// error，a是以复制方式捕获的，无法修改</span><br><span class="hljs-keyword">auto</span> f5 = [a]&#123; <span class="hljs-keyword">return</span> a + b; &#125;;          <span class="hljs-comment">// error，没有捕获变量b</span><br><span class="hljs-keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="hljs-keyword">return</span> a + (b++); &#125;;  <span class="hljs-comment">// OK，捕获a和b的引用，并对b做自加运算</span><br><span class="hljs-keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="hljs-keyword">return</span> a + (b++); &#125;;  <span class="hljs-comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt笔记——零：相关常识</title>
    <link href="/2022/09/15/Qt%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%8E%E7%BF%BB%E9%87%91%E5%B8%81%E5%BC%80%E5%A7%8B%E8%AE%B2%E8%B5%B7%EF%BC%88%E9%9B%B6%EF%BC%9A%E5%B8%B8%E8%AF%86%EF%BC%89/"/>
    <url>/2022/09/15/Qt%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%8E%E7%BF%BB%E9%87%91%E5%B8%81%E5%BC%80%E5%A7%8B%E8%AE%B2%E8%B5%B7%EF%BC%88%E9%9B%B6%EF%BC%9A%E5%B8%B8%E8%AF%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言：关于-Qt-的常识"><a href="#前言：关于-Qt-的常识" class="headerlink" title="前言：关于 Qt 的常识"></a>前言：关于 Qt 的常识</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Qt 是基于C++的跨平台的图形界面引擎。</p><p>作为1991年诞生的一个C++框架，拥有<strong>跨平台</strong>、<strong>接口简单</strong>、<strong>内存回收简单</strong>等特点。</p><p>Qt 拥有商业版和开源版。其中开源版使用了商用必须遵循LGPL协议，即：软件通过类库引用方式（动态链接）闭源发布，或静态链接并开源发布。这其中细节比较复杂，可以查询[Qt官网][<a href="https://www.qt.io/zh-cn/download]%E3%80%82">https://www.qt.io/zh-cn/download]。</a></p><h2 id="Qt-三大基类"><a href="#Qt-三大基类" class="headerlink" title="Qt 三大基类"></a>Qt 三大基类</h2><p>Qt 包含三大基类： QWidget 、QMainWindow、QDialog<br>    QWidget：干净纯粹的用户页面。<br>    QMainWindow：主应用程序窗口，包含菜单栏、状态栏、工具栏、停靠窗口、中心窗口。<br>    QDialog：对话窗口。</p><h2 id="Qt-Project-的基本结构"><a href="#Qt-Project-的基本结构" class="headerlink" title="Qt Project 的基本结构"></a>Qt Project 的基本结构</h2><p>一个简单的Qt 项目也基本以这几个内容组成：项目管理文件或者工程管理文件 <strong>.pro</strong>、头文件 <strong>.h</strong> 和 源文件 <strong>.cpp</strong>。如果项目使用可视化设计，还会有设计文件 <strong>.ui</strong>；如果使用了图片、音频或视频等资源文件，还会有资源仓库 <strong>.qrc</strong>。</p><h2 id="优化内存回收的手段：对象树"><a href="#优化内存回收的手段：对象树" class="headerlink" title="优化内存回收的手段：对象树"></a>优化内存回收的手段：对象树</h2><p>前文提到 Qt 基于C++却能够实现更简便的内存回收，它的手段就是对象树。</p><p>什么是对象树？类似于数据结构中的树有节点和根节点，对象树的节点就是对象；节点有父亲和儿子，对象也有父类和子类。当一个对象被析构，在它下方的子类也随之被析构，这样就实现了内存回收的功能。</p><p>当创建的对象在堆区时候，如果指定的父亲是QObject派生下来的类或者QObject子类派生下来的类，可以<strong>不用管理释放的操作，该对象会放入到对象树中</strong>。</p><p>综上所述，Qt 通过对象树在一定程度上简化了内存回收机制。</p><p>ps：析构函数的析构动作是在自身右括号后，在函数外执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中.h文件和.cpp文件的区别</title>
    <link href="/2022/09/12/C++%E4%B8%AD%EF%BC%8C.h%E6%96%87%E4%BB%B6%E5%92%8C.cpp%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/09/12/C++%E4%B8%AD%EF%BC%8C.h%E6%96%87%E4%BB%B6%E5%92%8C.cpp%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="关于-h文件和-cpp文件的区别"><a href="#关于-h文件和-cpp文件的区别" class="headerlink" title="关于.h文件和.cpp文件的区别"></a>关于.h文件和.cpp文件的区别</h1><h2 id="头文件：-h"><a href="#头文件：-h" class="headerlink" title="头文件：.h"></a>头文件：.h</h2><p>头文件的名字常常出现在代码最开始#include中。<br>顾名思义，不包含具体实现方法和细节，作用类似于抽象类。<br>主要内容是<strong>类的声明（包括成员和方法）</strong>、<strong>函数原型</strong>以及 <strong># define 常数</strong>。</p><h2 id="源文件：-cpp"><a href="#源文件：-cpp" class="headerlink" title="源文件：.cpp"></a>源文件：.cpp</h2><p>开头需要# include 具体实现的头文件和需要用到的头文件。<br>主要内容是头文件中声明的具体函数代码</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>在头文件<strong>Coder.h</strong>中定义Coder类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CODER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CODER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coder</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Coder</span>(std::string name);<br><br><span class="hljs-keyword">private</span>:<br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>然后在源文件<strong>test.cpp</strong>中引入了这个头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Coder.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>Coder::<span class="hljs-built_in">Coder</span>(string name) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Who isn&#x27;t a coder?&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">Coder <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;JerryG&quot;</span>)</span></span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">Who isn<span class="hljs-symbol">&#x27;t</span> a coder?<br>JerryG<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>头文件中不包含方法具体实现细节，但是常包含方法和成员的定义。如果一个类需要调用到另一个类，则需要在自身的头文件中使用<code>#include &quot;对应的类&quot;</code>。</p><p>而源文件中包含了方法的具体实现细节，不包含类的定义。</p><p>举一个不恰当的例子，头文件类似写作时的大纲，简单却不可或缺；源文件则类似根据大纲填充的细节，详细却依赖于大纲的内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Ubuntu安装QT及相关环境配置的经历</title>
    <link href="/2022/08/18/%E5%9C%A8Ubuntu%E5%AE%89%E8%A3%85QT%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <url>/2022/08/18/%E5%9C%A8Ubuntu%E5%AE%89%E8%A3%85QT%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="在Ubuntu安装QT及相关环境配置"><a href="#在Ubuntu安装QT及相关环境配置" class="headerlink" title="在Ubuntu安装QT及相关环境配置"></a>在Ubuntu安装QT及相关环境配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于相关项目需要在虚拟机中使用Ubuntu配置QT项目，记录折磨我的QT安装过程，以及第一次的Linux命令行使用经历。</p><hr><h2 id="安装QT"><a href="#安装QT" class="headerlink" title="安装QT"></a>安装QT</h2><p>由于命令行直接下载QT会有报错风险，因此从<a href="http://download.qt.io/archive/qt/">官网</a>下载QT的安装包，在本地安装。本次使用的是Ubuntu22.04以及QT5.12.0，下文皆使用此版本作为示例。注意，如果是刚配置好的Ubuntu系统，建议先进行一次更新，否则之后可能会遇到问题。</p><p>第一次使用Ubuntu，遇见.run格式文件还不知道怎么打开。是要使用相关命令行执行这个文件，具体操作如下：</p><ol><li>使用cd命令，切换至安装包所在的目录下。</li><li>使用命令<code>sudo chmod +x qt-opensource-linux-x64-5.12.0.run</code>，获取安装包打开权限。由于是超级命令<code>sudo</code>，故此处需要输入用户密码，输入时不会显示，完成直接回车即可。</li><li>使用命令<code>./qt-opensource-linux-x64-5.12.0.run</code> 运行安装包。</li><li>此处将弹出QT图形化安装界面，注册用户或直接跳过均可，不建议更改安装目录。</li><li>在安装选项中，如果外存充足可全部打勾。此处我选择安装gcc_64（必选）和Android相关（可选），在Tools中勾选qt creator，下一步即安装。</li><li>安装结束后，不要打开qt creator，我们接下来需要配置相关环境。</li></ol><h2 id="配置QT环境"><a href="#配置QT环境" class="headerlink" title="配置QT环境"></a>配置QT环境</h2><p>接下来需要在任意处打开终端配置QT环境。注意，进行这一步之前建议墙内用户在更新设置中手动将更新源替换成阿里云，以提高下载速度和成功率。</p><ol><li>使用命令<code>sudo apt-get install gcc g++</code> 安装gcc和g++，安装完成后可输入<code>gcc -v</code> 以及<code>g++ -v</code> 检查是否出现版本号确认安装成功。</li><li>使用命令<code>sudo apt-get install build-essential</code> 安装编译工具。</li><li>使用命令<code>sudo apt-get install vim</code> 安装vim。vim是Linux系统中常用的vi编辑器，可以主动识别语法，方便程序编辑。此步可省。</li><li>由于此版本Ubuntu已经自带很多开发所需的库，此处不再安装其他库，若开发中出现报错再手动安装。</li><li>接下来给qt添加环境变量，可以参考B站的<a href="https://www.bilibili.com/video/BV19r4y1N7UT?p=1&t=69">这个视频</a>，此处不再赘述。</li><li>最后，打开qt creator吧，我们还有最后几个步骤要做。</li></ol><h2 id="打开QT-creator"><a href="#打开QT-creator" class="headerlink" title="打开QT  creator"></a>打开QT  creator</h2><p>打开qt creator后，任选一个示例项目打开，是否发现部分代码行右侧有红色标注？如果有，在关于插件中取消勾选<strong>ClangCodeModel</strong>。</p><p>试着点一下左下角的run吧，运气好的话，我们应该能够成功运行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的博客搭建之路</title>
    <link href="/2022/08/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/"/>
    <url>/2022/08/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-我的博客折腾之路"><a href="#0x00-我的博客折腾之路" class="headerlink" title="0x00 我的博客折腾之路"></a>0x00 我的博客折腾之路</h1><p>GitHub→码云→csdn→放弃</p><p>~~~</p><h1 id="0x01-养成写笔记的习惯"><a href="#0x01-养成写笔记的习惯" class="headerlink" title="0x01 养成写笔记的习惯"></a>0x01 养成写笔记的习惯</h1><h1 id="0x02-搭建一个免费的博客吧！"><a href="#0x02-搭建一个免费的博客吧！" class="headerlink" title="0x02 搭建一个免费的博客吧！"></a>0x02 搭建一个免费的博客吧！</h1><h2 id="GitHub博客"><a href="#GitHub博客" class="headerlink" title="GitHub博客"></a>GitHub博客</h2><h2 id="gitee博客"><a href="#gitee博客" class="headerlink" title="gitee博客"></a>gitee博客</h2><h1 id="0x03-HelloWorld！"><a href="#0x03-HelloWorld！" class="headerlink" title="0x03 HelloWorld！"></a>0x03 HelloWorld！</h1>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
